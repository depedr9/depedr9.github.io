---
title: BlackHat MEA CTF 2022‚Ää‚Äî‚ÄäForensic challenges
date: 2025-08-21 11:26:15
tags: forensics
---
{% asset_img image.png "Alt text" %}
The challenge, titled ‚ÄúMem,‚Äù fell under the Forensics section. Participants were given an archive containing a raw memory image, along with the following description of the problem and this is my approach to solving the challenge in BlackHat MEA CTF 2022.

I found this particular task engaging because of its complexity, and I wanted to share the experience since i was completely noob at the time and just starting my ctf journey 
{% asset_img image-1.png "Alt text" %}

we had a raw memory image that has been acquired before the pc shutsdown and we have to do a memory forensics analysis of this image  

# Volatility
{% asset_img volitility.png "Alt text" %}

Volatility is an advanced memory forensics framework, implemented in python under the GNU General Public License, for the extraction of digital artifacts from volatile memory (RAM) samples. The extraction techniques are preformed completely independent of the system being investigated but offer visibility into the runtime state of the system. The framework is intended to introduce people to the techniques and complexities associated with extracting digital artifacts from volatile memory samples and provide a platform for further work in this exciting area of research.  

# Soultion 
First things first, as I‚Äôm currently studying for the eCDFP, I had to go through the whole forensics response steps.. and yeah, that also meant doing the good old byte-to-byte copy of the image. of course I didn‚Äôt touch the original, I did all my analysis on the copy ‚Üí just to get used to best practices

Then i started directly working with the raw image,First i had to get some info about the image so i did 

```bash
python2 /usr/bin/vol.py -f mem.raw imageinfo
```

{% asset_img mem1.png "Alt text" %}

The imageinfo output suggests which profile you should use with the `--profile=PROFILE` parameter when running other plugins. Sometimes, you might see more than one suggested profile if the profiles are closely related. It also shows the address of the KDBG structure (_KDDEBUGGER_DATA64), which plugins like pslist and modules rely on to locate the process list and module list heads.

Now we understood that the profile is Win7SP1x64 let's start looking at other stuff like pslist, pscan, etc.

### What is pslist?

To list the processes of a system, use the pslist command. This walks the doubly-linked list pointed to by PsActiveProcessHead and shows the offset, process name, process ID, the parent process ID, number of threads, number of handles, and date/time when the process started and exited. As of 2.1 it also shows the Session ID and if the process is a Wow64 process (it uses a 32-bit address space on a 64-bit kernel).

### What is psscan?

To enumerate processes using pool tag scanning (_POOL_HEADER), use the psscan command. This can find processes that were previously terminated (inactive) and processes that have been hidden or unlinked by a rootkit. The downside is that rootkits can still hide by overwriting the pool tag values (though not commonly seen in the wild).

```bash
python2 /usr/bin/vol.py -f mem.raw ‚Äî profile=Win7SP1x64 pslist
```
{% asset_img mem2.png "Alt text" %}

I haven't found anything suspicious where I can hunt more for flag, than I thought to find file objects in memory because I wanted to look for files that were relevant to the challenge hence I used filescan to do the same.

### What is filescan?

To find FILE_OBJECTs in physical memory using pool tag scanning, use the filescan command. This will find open files even if a rootkit is hiding the files on disk and if the rootkit hooks some API functions to hide the open handles on a live system. The output shows the physical offset of the FILE_OBJECT, file name, number of pointers to the object, number of handles to the object, and the effective permissions granted to the object.

{% asset_img mem3.png "Alt text" %}

As it was a large data to find hence I greped for words like ctf, flag for further hunting.

```bash 
python2 /usr/bin/vol.py -f mem.raw ‚Äî profile=Win7SP1x64 filescan | grep ctf

python2 /usr/bin/vol.py -f mem.raw ‚Äî profile=Win7SP1x64 filescan | grep flag
```

{% asset_img mem4.png "Alt text" %}

we have see the "flag.rar" file which seems to be our targeted file

I started dumping the file using the below command

```bash 
python2 /usr/bin/vol.py -f mem.raw ‚Äî profile=Win7SP1x64 dumpfiles -Q 0x000000001bbff9c0 -D /your/path/to/save/file
```
{% asset_img mem5.png "Alt text" %}

Upon opening the rar file we see that it is password protected, So sadly ... more research to do 
{% asset_img mem6.png "Alt text" %}

My first guess (and was the right one) is that the password is stored in the environment variables, So i used the envars plugin. Typically this will show the number of CPUs installed and the hardware architecture (though the kdbgscan output is a much more reliable source), the process's current directory, temporary directory, session name, computer name, user name, and various other interesting artifacts.

```bash 
python2 /usr/bin/vol.py -f mem.raw ‚Äî profile=Win7SP1x64 envars
```
{% asset_img mem7.png "Alt text" %}
As checked we found SystemP with a value Ittm1Fc7hcuFrLZIQmxs which seemed to be an off text and guessed it is password (and my guess ü§≠ again was correct).

{% asset_img memlast.png "Alt text" %}


```bash 
flag = BlackHatMEA{Password_hints_are_the_retrievable} 
```


We have been qualified for the BlackHat MEA 2022 Finals but sadly we werent able to make it to Riyadh üòì!!